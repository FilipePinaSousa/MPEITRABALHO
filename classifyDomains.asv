function classifyDomains(databaseFile, naiveBayesModel)
    % Load dataset
    data = readtable(databaseFile, 'TextType', 'string');
    
    % Load Naive Bayes model
    load(naiveBayesModel, 'model');  % Load the model trained in naiveBayesModel
    
    % Initialize list to store domain trust information
    domainTrustList = table('Size', [0 2], 'VariableTypes', {'string', 'logical'}, 'VariableNames', {'Domain', 'IsTrusted'});
    
    % Initialize counters for statistics
    totalDomains = 0;
    trustedCount = 0;
    untrustedCount = 0;
    
    % Create a bag-of-words object for the entire dataset (to match the model's feature set)
    documents = tokenizedDocument(data.title);
    bag = bagOfWords(documents);
    
    % Match feature space: Get the same set of top features as used in training
    [~, sortedIdx] = sort(sum(bag.Counts, 1), 'descend');  % Sort by word frequency
    topWordsIdx = sortedIdx(1:50);  % Example: select top 50 features like in training
    bagCounts = bag.Counts(:, topWordsIdx);  % Use only the top 50 words (features)
    
    % Process each article
    for i = 1:height(data)
        % Extract domain from URL
        domain = extractDomain(data.s(i));
        
        % Skip invalid URLs
        if strcmp(domain, 'Invalid URL')
            continue;
        end
        
        % Get true label for the article (assuming 'label' is 1 for true, 0 for fake)
        trueLabel = data.label(i);
        
        % Get the feature vector for the article (top words only)
        featureVector = bagCounts(i, :);  % Extract the feature vector for the i-th article
        
        % Make prediction using Naive Bayes model
        prediction = predictNaiveBayesModel(model, featureVector);
        
        % Determine trustworthiness based on prediction
        isTrusted = prediction == 1;  % If predicted as 'true' (1), it is trusted
        
        % Add domain and trust status to the list
        domainTrustList = [domainTrustList; {domain, isTrusted}];
        
        % Update counters
        totalDomains = totalDomains + 1;
        if isTrusted
            trustedCount = trustedCount + 1;
        else
            untrustedCount = untrustedCount + 1;
        end
        
        % Optionally display prediction vs actual
        if trueLabel == 1
            trueLabelStr = 'trusted';
        else
            trueLabelStr = 'untrusted';
        end
        
        if isTrusted
            predictionStr = 'trusted';
        else
            predictionStr = 'untrusted';
        end
        
        fprintf('Domain: %s, True Label: %s, Predicted: %s\n', domain, trueLabelStr, predictionStr);
    end
    
    % Show the trust list
    disp('Domain Trust List:');
    disp(domainTrustList);
    
    % Display Summary Statistics
    fprintf('Total Domains Processed: %d\n', totalDomains);
    fprintf('Trusted Domains: %d\n', trustedCount);
    fprintf('Untrusted Domains: %d\n', untrustedCount);
    fprintf('Percentage Trusted: %.2f%%\n', (trustedCount / totalDomains) * 100);
    fprintf('Percentage Untrusted: %.2f%%\n', (untrustedCount / totalDomains) * 100);
end

% Naive Bayes prediction function using priors and conditional probabilities
function prediction = predictNaiveBayesModel(model, featureVector)
    % Initialize prediction variable
    numClasses = numel(model.classLabels);
    classLogProbs = log(model.priors);  % Start with log priors
    
    % Compute the log likelihood for each class
    for classIdx = 1:numClasses
        % Add log probabilities of each feature given the class
        classLogProbs(classIdx) = classLogProbs(classIdx) + sum(log(model.condProbs(classIdx, :) .^ featureVector));
    end
    
    % Predict the class with the highest log probability
    [~, predictedClassIdx] = max(classLogProbs);
    prediction = model.classLabels(predictedClassIdx);
end
